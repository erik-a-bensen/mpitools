name: Update Documentation
on:
  push:
    branches: [main]
    # paths: ['**/*.py']

permissions:
  contents: write

jobs:
  update-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
          
      - name: Install MPI
        run: |
          sudo apt-get update
          sudo apt-get install -y libopenmpi-dev openmpi-bin
          
      - name: Install dependencies
        run: |
          pip install -e .
          
      - name: Generate docs manually
        run: |
          python -c "
          import sys
          sys.path.insert(0, 'src')
          import mpitools
          import inspect
          import pkgutil
          import importlib
          
          def clean_signature(func):
              try:
                  sig = inspect.signature(func)
                  params = []
                  
                  for param_name, param in sig.parameters.items():
                      # Clean up the parameter representation
                      param_str = param_name
                      
                      # Add type annotation if present
                      if param.annotation != inspect.Parameter.empty:
                          annotation = str(param.annotation)
                          # Clean up common type annotations
                          annotation = annotation.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types
                          annotation = annotation.replace('collections.abc.Callable', 'Callable')
                          annotation = annotation.replace('typing.', '')
                          
                          # Remove <class '...'> wrappers
                          if annotation.startswith('<class \'') and annotation.endswith('\'>'):
                              annotation = annotation[8:-2]  # Remove '<class \'' and '\'>'
                          elif annotation.startswith('<') and annotation.endswith('>'):
                              # Handle other object representations
                              if 'class' in annotation:
                                  parts = annotation.split('.')
                                  if len(parts) > 1:
                                      annotation = parts[-1].rstrip('\'>')
                          
                          param_str += f': {annotation}'
                      
                      # Add default value if present
                      if param.default != inspect.Parameter.empty:
                          default = str(param.default)
                          # Clean up common default values
                          if 'COMM_WORLD' in default or 'Intracomm' in default:
                              default = 'MPI.COMM_WORLD'
                          elif 'Exception' in default:
                              default = 'Exception'
                          elif default == 'sum':  # Handle the 'sum' default for reduce operations
                              default = '\'sum\''
                          elif default.startswith('<') and default.endswith('>'):
                              # Generic cleanup for object representations
                              if 'COMM_WORLD' in str(param.default.__class__.__name__) or 'Comm' in str(type(param.default).__name__):
                                  default = 'MPI.COMM_WORLD'
                          param_str += f' = {default}'
                      
                      params.append(param_str)
                  
                  # Handle return annotation
                  return_annotation = ''
                  if sig.return_annotation != inspect.Signature.empty:
                      ret_ann = str(sig.return_annotation)
                      ret_ann = ret_ann.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types in return
                      ret_ann = ret_ann.replace('collections.abc.Callable', 'Callable')
                      ret_ann = ret_ann.replace('typing.', '')
                      
                      # Remove <class '...'> wrappers from return type
                      if ret_ann.startswith('<class \'') and ret_ann.endswith('\'>'):
                          ret_ann = ret_ann[8:-2]  # Remove '<class \'' and '\'>'
                      
                      return_annotation = f' -> {ret_ann}'
                  
                  return f'({', '.join(params)}){return_annotation}'
              except (ValueError, TypeError):
                  return '(...)'
          
          def document_module(module, module_name):
              docs = []
              print(f'=== Documenting {module_name} ===')
              
              # Use __all__ order if available, otherwise fall back to dir()
              if hasattr(module, '__all__'):
                  names_to_document = module.__all__
                  print(f'Using __all__ order: {names_to_document}')
              else:
                  names_to_document = [name for name in dir(module) if not name.startswith('_')]
                  print(f'Using alphabetical order: {names_to_document}')
              
              for name in names_to_document:
                  if hasattr(module, name):
                      obj = getattr(module, name)
                      if hasattr(obj, '__doc__') and obj.__doc__:
                          if callable(obj):
                              sig = clean_signature(obj)
                              docs.append(f'## \`{name}\`\n\n\`\`\`python\n{name}{sig}\n\`\`\`\n\n{obj.__doc__}\n')
                          elif inspect.isclass(obj):
                              # Document classes
                              docs.append(f'## \`{name}\` (class)\n\n{obj.__doc__}\n')
              return docs
          
          all_docs = []
          
          # Document main module
          main_docs = document_module(mpitools, 'mpitools')
          all_docs.extend(main_docs)
          
          # Discover and document subpackages (only those with __init__.py)
          package_path = mpitools.__path__[0] if hasattr(mpitools, '__path__') else None
          if package_path:
              for importer, modname, ispkg in pkgutil.iter_modules([package_path]):
                  if not modname.startswith('_') and ispkg:  # Only include packages (with __init__.py)
                      try:
                          submodule = importlib.import_module(f'mpitools.{modname}')
                          all_docs.append(f'\n---\n\n# {modname.title()} Submodule\n\n')
                          sub_docs = document_module(submodule, f'mpitools.{modname}')
                          all_docs.extend(sub_docs)
                      except ImportError as e:
                          print(f'Could not import mpitools.{modname}: {e}')
          
          with open('temp_docs.md', 'w') as f:
              f.write('\n'.join(all_docs))
          "
          
      - name: Update README with custom docs
        run: |
          sed -i '/^# API Reference/,$d' README.md
          echo "" >> README.md
          echo "# API Reference" >> README.md
          echo "" >> README.md
          cat temp_docs.md >> README.md
          rm temp_docs.md
          
      - name: Commit changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          git diff --staged --quiet || git commit -m "Auto-update README with API docs [skip ci]"
          git push
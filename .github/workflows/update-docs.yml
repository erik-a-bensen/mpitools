name: Update Documentation
on:
  push:
    branches: [main]
    paths: ['**/*.py']

permissions:
  contents: write

jobs:
  update-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
          
      - name: Install MPI
        run: |
          sudo apt-get update
          sudo apt-get install -y libopenmpi-dev openmpi-bin
          
      - name: Install dependencies
        run: |
          pip install -e .
          
      - name: Generate docs manually
        run: |
          python -c "
          import sys
          sys.path.insert(0, 'src')
          import mpitools
          import inspect
          import pkgutil
          import importlib
          import re
          
          def clean_docstring(docstring):
              if not docstring:
                  return None
              
              # Clean the docstring first
              cleaned = inspect.cleandoc(docstring)
              lines = cleaned.split('\n')
              result = []
              
              for line in lines:
                  if line.strip() == '':
                      # Preserve blank lines
                      result.append('')
                  else:
                      # Convert leading spaces to non-breaking spaces to preserve indentation
                      stripped = line.lstrip()
                      leading_spaces = len(line) - len(stripped)
                      
                      if leading_spaces > 0:
                          # Convert spaces to &nbsp; to preserve indentation in markdown
                          indent = '&nbsp;' * (leading_spaces * 2)  # Use 2 &nbsp; per space for better visibility
                          result.append(f'{indent}{stripped}')
                      else:
                          result.append(stripped)
              
              return '\\n'.join(result)
          
          def clean_signature(func):
              try:
                  sig = inspect.signature(func)
                  params = []
                  
                  for param_name, param in sig.parameters.items():
                      # Clean up the parameter representation
                      param_str = param_name
                      
                      # Add type annotation if present
                      if param.annotation != inspect.Parameter.empty:
                          annotation = str(param.annotation)
                          # Clean up common type annotations
                          annotation = annotation.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types
                          annotation = annotation.replace('collections.abc.Callable', 'Callable')
                          annotation = annotation.replace('typing.', '')
                          
                          # Clean up internal module paths to public import paths (generic)
                          # Pattern: mpitools.{submodule}.{internal_module}.{Class} -> mpitools.{submodule}.{Class}
                          annotation = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', annotation)
                          
                          # Remove <class '...'> wrappers
                          if annotation.startswith('<class \'') and annotation.endswith('\'>'):
                              annotation = annotation[8:-2]  # Remove '<class \'' and '\'>'
                          elif annotation.startswith('<') and annotation.endswith('>'):
                              # Handle other object representations
                              if 'class' in annotation:
                                  parts = annotation.split('.')
                                  if len(parts) > 1:
                                      annotation = parts[-1].rstrip('\'>')
                          
                          param_str += f': {annotation}'
                      
                      # Add default value if present
                      if param.default != inspect.Parameter.empty:
                          default = str(param.default)
                          # Clean up common default values
                          if 'COMM_WORLD' in default or 'Intracomm' in default:
                              default = 'MPI.COMM_WORLD'
                          elif 'Exception' in default:
                              default = 'Exception'
                          elif default == 'sum':  # Handle the 'sum' default for reduce operations
                              default = '\'sum\''
                          elif default.startswith('<') and default.endswith('>'):
                              # Generic cleanup for object representations
                              if 'COMM_WORLD' in str(param.default.__class__.__name__) or 'Comm' in str(type(param.default).__name__):
                                  default = 'MPI.COMM_WORLD'
                          param_str += f' = {default}'
                      
                      params.append(param_str)
                  
                  # Handle return annotation
                  return_annotation = ''
                  if sig.return_annotation != inspect.Signature.empty:
                      ret_ann = str(sig.return_annotation)
                      ret_ann = ret_ann.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types in return
                      ret_ann = ret_ann.replace('collections.abc.Callable', 'Callable')
                      ret_ann = ret_ann.replace('typing.', '')
                      
                      # Clean up internal module paths in return types too (generic)
                      ret_ann = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', ret_ann)
                      
                      # Remove <class '...'> wrappers from return type
                      if ret_ann.startswith('<class \'') and ret_ann.endswith('\'>'):
                          ret_ann = ret_ann[8:-2]  # Remove '<class \'' and '\'>'
                      
                      return_annotation = f' -> {ret_ann}'
                  
                  return f'({', '.join(params)}){return_annotation}'
              except (ValueError, TypeError):
                  return '(...)'
          
          def clean_constructor_signature(func, class_name):
              try:
                  sig = inspect.signature(func)
                  params = []
                  
                  for param_name, param in sig.parameters.items():
                      # Skip 'self' parameter for constructors
                      if param_name == 'self':
                          continue
                          
                      # Clean up the parameter representation
                      param_str = param_name
                      
                      # Add type annotation if present
                      if param.annotation != inspect.Parameter.empty:
                          annotation = str(param.annotation)
                          # Clean up common type annotations
                          annotation = annotation.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types
                          annotation = annotation.replace('collections.abc.Callable', 'Callable')
                          annotation = annotation.replace('typing.', '')
                          
                          # Clean up internal module paths to public import paths (generic)
                          annotation = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', annotation)
                          
                          # Remove <class '...'> wrappers
                          if annotation.startswith('<class \'') and annotation.endswith('\'>'):
                              annotation = annotation[8:-2]  # Remove '<class \'' and '\'>'
                          elif annotation.startswith('<') and annotation.endswith('>'):
                              # Handle other object representations
                              if 'class' in annotation:
                                  parts = annotation.split('.')
                                  if len(parts) > 1:
                                      annotation = parts[-1].rstrip('\'>')
                          
                          param_str += f': {annotation}'
                      
                      # Add default value if present
                      if param.default != inspect.Parameter.empty:
                          default = str(param.default)
                          # Clean up common default values
                          if 'COMM_WORLD' in default or 'Intracomm' in default:
                              default = 'MPI.COMM_WORLD'
                          elif 'Exception' in default:
                              default = 'Exception'
                          elif default == 'sum':
                              default = '\'sum\''
                          elif default.startswith('<') and default.endswith('>'):
                              if 'COMM_WORLD' in str(param.default.__class__.__name__) or 'Comm' in str(type(param.default).__name__):
                                  default = 'MPI.COMM_WORLD'
                          param_str += f' = {default}'
                      
                      params.append(param_str)
                  
                  return f'{class_name}({', '.join(params)})'
              except (ValueError, TypeError):
                  return f'{class_name}(...)'
          
          def document_class(cls, class_name):
              docs = []
              
              # Document the class header
              docs.append(f'## \`{class_name}\` (class)')
              docs.append('')
              
              # Add constructor signature if __init__ exists
              if hasattr(cls, '__init__'):
                  try:
                      constructor_sig = clean_constructor_signature(cls.__init__, class_name)
                      docs.append('\`\`\`python')
                      docs.append(constructor_sig)
                      docs.append('\`\`\`')
                      docs.append('')
                  except (AttributeError, TypeError):
                      docs.append('\`\`\`python')
                      docs.append(f'{class_name}(...)')
                      docs.append('\`\`\`')
                      docs.append('')
              
              # Handle docstrings - show both class and __init__ docstrings if they exist
              class_docstring = clean_docstring(cls.__doc__)
              init_docstring = None
              if hasattr(cls, '__init__'):
                  init_docstring = clean_docstring(cls.__init__.__doc__)
              
              if class_docstring and init_docstring:
                  # Both exist - show class docstring, then init docstring
                  docs.append(class_docstring)
                  docs.append('')
                  docs.append('**Constructor:**')
                  docs.append('')
                  docs.append(init_docstring)
                  docs.append('')
              elif class_docstring:
                  # Only class docstring
                  docs.append(class_docstring)
                  docs.append('')
              elif init_docstring:
                  # Only init docstring
                  docs.append(init_docstring)
                  docs.append('')
              else:
                  # No docstrings
                  docs.append('*No description available.*')
                  docs.append('')
              
              # Document public methods
              methods = []
              for method_name in dir(cls):
                  if not method_name.startswith('_'):
                      try:
                          method = getattr(cls, method_name)
                          if callable(method) and method.__doc__:
                              sig = clean_signature(method)
                              cleaned_method_doc = clean_docstring(method.__doc__)
                              if cleaned_method_doc:
                                  methods.append(f'### \`{method_name}\`')
                                  methods.append('')
                                  methods.append('\`\`\`python')
                                  methods.append(f'{method_name}{sig}')
                                  methods.append('\`\`\`')
                                  methods.append('')
                                  methods.append(cleaned_method_doc)
                                  methods.append('')
                      except (AttributeError, TypeError):
                          continue
              
              if methods:
                  docs.append('### Methods')
                  docs.append('')
                  docs.extend(methods)
              
              return docs
          
          def document_module(module, module_name):
              docs = []
              print(f'=== Documenting {module_name} ===')
              
              # Use __all__ order if available, otherwise fall back to dir()
              if hasattr(module, '__all__'):
                  names_to_document = module.__all__
                  print(f'Using __all__ order: {names_to_document}')
              else:
                  names_to_document = [name for name in dir(module) if not name.startswith('_')]
                  print(f'Using alphabetical order: {names_to_document}')
              
              for name in names_to_document:
                  if hasattr(module, name):
                      obj = getattr(module, name)
                      if inspect.isclass(obj):
                          # Document classes with their methods (even if class has no docstring)
                          print(f'  Found class: {name}')
                          class_docs = document_class(obj, name)
                          docs.extend(class_docs)
                      elif callable(obj) and obj.__doc__:
                          # Document functions only if they have docstrings
                          sig = clean_signature(obj)
                          cleaned_func_doc = clean_docstring(obj.__doc__)
                          if cleaned_func_doc:
                              docs.append(f'## \`{name}\`')
                              docs.append('')
                              docs.append('\`\`\`python')
                              docs.append(f'{name}{sig}')
                              docs.append('\`\`\`')
                              docs.append('')
                              docs.append(cleaned_func_doc)
                              docs.append('')
              return docs
          
          all_docs = []
          
          # Add header to the API docs
          all_docs.append('# API Reference')
          all_docs.append('')
          all_docs.append('> **⚠️ Development Version**: This API is subject to change until v1.0.0. Breaking changes may occur in minor releases.')
          all_docs.append('')
          
          # Document main module
          main_docs = document_module(mpitools, 'mpitools')
          all_docs.extend(main_docs)
          
          # Discover and document subpackages (only those with __init__.py)
          package_path = mpitools.__path__[0] if hasattr(mpitools, '__path__') else None
          if package_path:
              for importer, modname, ispkg in pkgutil.iter_modules([package_path]):
                  if not modname.startswith('_') and ispkg:  # Only include packages (with __init__.py)
                      try:
                          submodule = importlib.import_module(f'mpitools.{modname}')
                          all_docs.append('---')
                          all_docs.append('')
                          all_docs.append(f'# {modname.title()} Submodule')
                          all_docs.append('')
                          sub_docs = document_module(submodule, f'mpitools.{modname}')
                          all_docs.extend(sub_docs)
                      except ImportError as e:
                          print(f'Could not import mpitools.{modname}: {e}')
          
          with open('API_DOCS.md', 'w') as f:
              f.write('\n'.join(all_docs))
          "
          
      - name: Commit changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add API_DOCS.md
          git diff --staged --quiet || git commit -m "Auto-update API documentation [skip ci]"
          git push
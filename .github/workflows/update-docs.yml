name: Update Documentation
on:
  push:
    branches: [main]
    # paths: ['**/*.py']

permissions:
  contents: write

jobs:
  update-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
          
      - name: Install MPI
        run: |
          sudo apt-get update
          sudo apt-get install -y libopenmpi-dev openmpi-bin
          
      - name: Install dependencies
        run: |
          pip install -e .
          
      - name: Generate docs manually
        run: |
          python -c "
          import sys
          sys.path.insert(0, 'src')
          import mpitools
          import inspect
          import pkgutil
          import importlib
          import re
          
          def clean_signature(func):
              try:
                  sig = inspect.signature(func)
                  params = []
                  
                  for param_name, param in sig.parameters.items():
                      # Clean up the parameter representation
                      param_str = param_name
                      
                      # Add type annotation if present
                      if param.annotation != inspect.Parameter.empty:
                          annotation = str(param.annotation)
                          # Clean up common type annotations
                          annotation = annotation.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types
                          annotation = annotation.replace('collections.abc.Callable', 'Callable')
                          annotation = annotation.replace('typing.', '')
                          
                          # Clean up internal module paths to public import paths (generic)
                          # Pattern: mpitools.{submodule}.{internal_module}.{Class} -> mpitools.{submodule}.{Class}
                          annotation = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', annotation)
                          
                          # Remove <class '...'> wrappers
                          if annotation.startswith('<class \'') and annotation.endswith('\'>'):
                              annotation = annotation[8:-2]  # Remove '<class \'' and '\'>'
                          elif annotation.startswith('<') and annotation.endswith('>'):
                              # Handle other object representations
                              if 'class' in annotation:
                                  parts = annotation.split('.')
                                  if len(parts) > 1:
                                      annotation = parts[-1].rstrip('\'>')
                          
                          param_str += f': {annotation}'
                      
                      # Add default value if present
                      if param.default != inspect.Parameter.empty:
                          default = str(param.default)
                          # Clean up common default values
                          if 'COMM_WORLD' in default or 'Intracomm' in default:
                              default = 'MPI.COMM_WORLD'
                          elif 'Exception' in default:
                              default = 'Exception'
                          elif default == 'sum':  # Handle the 'sum' default for reduce operations
                              default = '\'sum\''
                          elif default.startswith('<') and default.endswith('>'):
                              # Generic cleanup for object representations
                              if 'COMM_WORLD' in str(param.default.__class__.__name__) or 'Comm' in str(type(param.default).__name__):
                                  default = 'MPI.COMM_WORLD'
                          param_str += f' = {default}'
                      
                      params.append(param_str)
                  
                  # Handle return annotation
                  return_annotation = ''
                  if sig.return_annotation != inspect.Signature.empty:
                      ret_ann = str(sig.return_annotation)
                      ret_ann = ret_ann.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types in return
                      ret_ann = ret_ann.replace('collections.abc.Callable', 'Callable')
                      ret_ann = ret_ann.replace('typing.', '')
                      
                      # Clean up internal module paths in return types too (generic)
                      ret_ann = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', ret_ann)
                      
                      # Remove <class '...'> wrappers from return type
                      if ret_ann.startswith('<class \'') and ret_ann.endswith('\'>'):
                          ret_ann = ret_ann[8:-2]  # Remove '<class \'' and '\'>'
                      
                      return_annotation = f' -> {ret_ann}'
                  
                  return f'({', '.join(params)}){return_annotation}'
              except (ValueError, TypeError):
                  return '(...)'
          
          def clean_constructor_signature(func, class_name):
              try:
                  sig = inspect.signature(func)
                  params = []
                  
                  for param_name, param in sig.parameters.items():
                      # Skip 'self' parameter for constructors
                      if param_name == 'self':
                          continue
                          
                      # Clean up the parameter representation
                      param_str = param_name
                      
                      # Add type annotation if present
                      if param.annotation != inspect.Parameter.empty:
                          annotation = str(param.annotation)
                          # Clean up common type annotations
                          annotation = annotation.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types
                          annotation = annotation.replace('collections.abc.Callable', 'Callable')
                          annotation = annotation.replace('typing.', '')
                          
                          # Clean up internal module paths to public import paths (generic)
                          annotation = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', annotation)
                          
                          # Remove <class '...'> wrappers
                          if annotation.startswith('<class \'') and annotation.endswith('\'>'):
                              annotation = annotation[8:-2]  # Remove '<class \'' and '\'>'
                          elif annotation.startswith('<') and annotation.endswith('>'):
                              # Handle other object representations
                              if 'class' in annotation:
                                  parts = annotation.split('.')
                                  if len(parts) > 1:
                                      annotation = parts[-1].rstrip('\'>')
                          
                          param_str += f': {annotation}'
                      
                      # Add default value if present
                      if param.default != inspect.Parameter.empty:
                          default = str(param.default)
                          # Clean up common default values
                          if 'COMM_WORLD' in default or 'Intracomm' in default:
                              default = 'MPI.COMM_WORLD'
                          elif 'Exception' in default:
                              default = 'Exception'
                          elif default == 'sum':
                              default = '\'sum\''
                          elif default.startswith('<') and default.endswith('>'):
                              if 'COMM_WORLD' in str(param.default.__class__.__name__) or 'Comm' in str(type(param.default).__name__):
                                  default = 'MPI.COMM_WORLD'
                          param_str += f' = {default}'
                      
                      params.append(param_str)
                  
                  return f'{class_name}({', '.join(params)})'
              except (ValueError, TypeError):
                  return f'{class_name}(...)'
          
          def document_class(cls, class_name):
              docs = []
              
              # Document the class header
              docs.append(f'## \`{class_name}\` (class)\n')
              
              # Add constructor signature if __init__ exists
              if hasattr(cls, '__init__'):
                  try:
                      constructor_sig = clean_constructor_signature(cls.__init__, class_name)
                      docs.append(f'\`\`\`python\n{constructor_sig}\n\`\`\`\n')
                  except (AttributeError, TypeError):
                      docs.append(f'\`\`\`python\n{class_name}(...)\n\`\`\`\n')
              
              # Handle docstrings - show both class and __init__ docstrings if they exist
              class_docstring = cls.__doc__ if cls.__doc__ else None
              init_docstring = None
              if hasattr(cls, '__init__') and cls.__init__.__doc__:
                  init_docstring = cls.__init__.__doc__
              
              if class_docstring and init_docstring:
                  # Both exist - show class docstring, then init docstring
                  docs.append(f'{class_docstring}\n')
                  docs.append(f'**Constructor:**\n\n{init_docstring}\n')
              elif class_docstring:
                  # Only class docstring
                  docs.append(f'{class_docstring}\n')
              elif init_docstring:
                  # Only init docstring
                  docs.append(f'{init_docstring}\n')
              else:
                  # No docstrings
                  docs.append('*No description available.*\n')
              
              # Document public methods
              methods = []
              for method_name in dir(cls):
                  if not method_name.startswith('_'):
                      try:
                          method = getattr(cls, method_name)
                          if callable(method) and hasattr(method, '__doc__') and method.__doc__:
                              sig = clean_signature(method)
                              methods.append(f'### \`{method_name}\`\n\n\`\`\`python\n{method_name}{sig}\n\`\`\`\n\n{method.__doc__}\n')
                      except (AttributeError, TypeError):
                          continue
              
              if methods:
                  docs.append('### Methods\n')
                  docs.extend(methods)
              
              return docs
          
          def document_module(module, module_name):
              docs = []
              print(f'=== Documenting {module_name} ===')
              
              # Use __all__ order if available, otherwise fall back to dir()
              if hasattr(module, '__all__'):
                  names_to_document = module.__all__
                  print(f'Using __all__ order: {names_to_document}')
              else:
                  names_to_document = [name for name in dir(module) if not name.startswith('_')]
                  print(f'Using alphabetical order: {names_to_document}')
              
              for name in names_to_document:
                  if hasattr(module, name):
                      obj = getattr(module, name)
                      if inspect.isclass(obj):
                          # Document classes with their methods (even if class has no docstring)
                          print(f'  Found class: {name}')
                          class_docs = document_class(obj, name)
                          docs.extend(class_docs)
                      elif callable(obj) and hasattr(obj, '__doc__') and obj.__doc__:
                          # Document functions only if they have docstrings
                          sig = clean_signature(obj)
                          docs.append(f'## \`{name}\`\n\n\`\`\`python\n{name}{sig}\n\`\`\`\n\n{obj.__doc__}\n')
              return docs
          
          all_docs = []
          
          # Add header to the API docs
          all_docs.append('# API Reference\n')
          
          # Document main module
          main_docs = document_module(mpitools, 'mpitools')
          all_docs.extend(main_docs)
          
          # Discover and document subpackages (only those with __init__.py)
          package_path = mpitools.__path__[0] if hasattr(mpitools, '__path__') else None
          if package_path:
              for importer, modname, ispkg in pkgutil.iter_modules([package_path]):
                  if not modname.startswith('_') and ispkg:  # Only include packages (with __init__.py)
                      try:
                          submodule = importlib.import_module(f'mpitools.{modname}')
                          all_docs.append(f'\n---\n\n# {modname.title()} Submodule\n\n')
                          sub_docs = document_module(submodule, f'mpitools.{modname}')
                          all_docs.extend(sub_docs)
                      except ImportError as e:
                          print(f'Could not import mpitools.{modname}: {e}')
          
          with open('API_DOCS.md', 'w') as f:
              f.write('\n'.join(all_docs))
          "
          
      - name: Commit changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add API_DOCS.md
          git diff --staged --quiet || git commit -m "Auto-update API documentation [skip ci]"
          git push
name: Update Documentation
on:
  push:
    branches: [main]
    paths: ['**/*.py']

permissions:
  contents: write

jobs:
  update-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
          
      - name: Install MPI
        run: |
          sudo apt-get update
          sudo apt-get install -y libopenmpi-dev openmpi-bin
          
      - name: Install dependencies
        run: |
          pip install -e .
          
      - name: Generate docs manually
        run: |
          python -c "
          import sys
          sys.path.insert(0, 'src')
          import mpitools
          import inspect
          import pkgutil
          import importlib
          import re
          
          def clean_signature(func):
              try:
                  sig = inspect.signature(func)
                  params = []
                  
                  for param_name, param in sig.parameters.items():
                      # Clean up the parameter representation
                      param_str = param_name
                      
                      # Add type annotation if present
                      if param.annotation != inspect.Parameter.empty:
                          annotation = str(param.annotation)
                          # Clean up common type annotations
                          annotation = annotation.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types
                          annotation = annotation.replace('collections.abc.Callable', 'Callable')
                          annotation = annotation.replace('typing.', '')
                          
                          # Clean up internal module paths to public import paths (generic)
                          # Pattern: mpitools.{submodule}.{internal_module}.{Class} -> mpitools.{submodule}.{Class}
                          annotation = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', annotation)
                          
                          # Remove <class '...'> wrappers
                          if annotation.startswith('<class \'') and annotation.endswith('\'>'):
                              annotation = annotation[8:-2]  # Remove '<class \'' and '\'>'
                          elif annotation.startswith('<') and annotation.endswith('>'):
                              # Handle other object representations
                              if 'class' in annotation:
                                  parts = annotation.split('.')
                                  if len(parts) > 1:
                                      annotation = parts[-1].rstrip('\'>')
                          
                          param_str += f': {annotation}'
                      
                      # Add default value if present
                      if param.default != inspect.Parameter.empty:
                          default = str(param.default)
                          # Clean up common default values
                          if 'COMM_WORLD' in default or 'Intracomm' in default:
                              default = 'MPI.COMM_WORLD'
                          elif 'Exception' in default:
                              default = 'Exception'
                          elif default == 'sum':  # Handle the 'sum' default for reduce operations
                              default = '\'sum\''
                          elif default.startswith('<') and default.endswith('>'):
                              # Generic cleanup for object representations
                              if 'COMM_WORLD' in str(param.default.__class__.__name__) or 'Comm' in str(type(param.default).__name__):
                                  default = 'MPI.COMM_WORLD'
                          param_str += f' = {default}'
                      
                      params.append(param_str)
                  
                  # Handle return annotation
                  return_annotation = ''
                  if sig.return_annotation != inspect.Signature.empty:
                      ret_ann = str(sig.return_annotation)
                      ret_ann = ret_ann.replace('mpi4py.MPI.', 'MPI.')  # Handle all MPI types in return
                      ret_ann = ret_ann.replace('collections.abc.Callable', 'Callable')
                      ret_ann = ret_ann.replace('typing.', '')
                      
                      # Clean up internal module paths in return types too (generic)
                      ret_ann = re.sub(r'mpitools\.([^.]+)\.([^.]+)\.([^.]+)', r'mpitools.\1.\3', ret_ann)
                      
                      # Remove <class '...'> wrappers from return type
                      if ret_ann.startswith('<class \'') and ret_ann.endswith('\'>'):
                          ret_ann = ret_ann[8:-2]  # Remove '<class \'' and '\'>'
                      
                      return_annotation = f' -> {ret_ann}'
                  
                  return f'({', '.join(params)}){return_annotation}'
              except (ValueError, TypeError):
                  return '(...)'
          
          def document_class(cls, class_name):
              docs = []
              # Document the class itself
              if cls.__doc__:
                  docs.append(f'## \`{class_name}\` (class)\n\n{cls.__doc__}\n')
              else:
                  docs.append(f'## \`{class_name}\` (class)\n\n*No description available.*\n')
              
              # Document __init__ method first if it exists and has a docstring
              if hasattr(cls, '__init__') and cls.__init__.__doc__:
                  try:
                      init_sig = clean_signature(cls.__init__)
                      docs.append(f'### \`__init__\`\n\n\`\`\`python\n__init__{init_sig}\n\`\`\`\n\n{cls.__init__.__doc__}\n')
                  except (AttributeError, TypeError):
                      pass
              
              # Document other public methods
              methods = []
              for method_name in dir(cls):
                  if not method_name.startswith('_') or method_name == '__init__':
                      # Skip __init__ since we handled it above
                      if method_name == '__init__':
                          continue
                      try:
                          method = getattr(cls, method_name)
                          if callable(method) and hasattr(method, '__doc__') and method.__doc__:
                              sig = clean_signature(method)
                              methods.append(f'### \`{method_name}\`\n\n\`\`\`python\n{method_name}{sig}\n\`\`\`\n\n{method.__doc__}\n')
                      except (AttributeError, TypeError):
                          continue
              
              if methods:
                  if not (hasattr(cls, '__init__') and cls.__init__.__doc__):
                      docs.append('### Methods\n')
                  docs.extend(methods)
              
              return docs
          
          def document_module(module, module_name):
              docs = []
              print(f'=== Documenting {module_name} ===')
              
              # Use __all__ order if available, otherwise fall back to dir()
              if hasattr(module, '__all__'):
                  names_to_document = module.__all__
                  print(f'Using __all__ order: {names_to_document}')
              else:
                  names_to_document = [name for name in dir(module) if not name.startswith('_')]
                  print(f'Using alphabetical order: {names_to_document}')
              
              for name in names_to_document:
                  if hasattr(module, name):
                      obj = getattr(module, name)
                      if hasattr(obj, '__doc__') and obj.__doc__:
                          if inspect.isclass(obj):
                              # Document classes with their methods
                              class_docs = document_class(obj, name)
                              docs.extend(class_docs)
                          elif callable(obj):
                              # Document functions
                              sig = clean_signature(obj)
                              docs.append(f'## \`{name}\`\n\n\`\`\`python\n{name}{sig}\n\`\`\`\n\n{obj.__doc__}\n')
              return docs
          
          all_docs = []
          
          # Add header to the API docs
          all_docs.append('# API Reference\n')
          
          # Document main module
          main_docs = document_module(mpitools, 'mpitools')
          all_docs.extend(main_docs)
          
          # Discover and document subpackages (only those with __init__.py)
          package_path = mpitools.__path__[0] if hasattr(mpitools, '__path__') else None
          if package_path:
              for importer, modname, ispkg in pkgutil.iter_modules([package_path]):
                  if not modname.startswith('_') and ispkg:  # Only include packages (with __init__.py)
                      try:
                          submodule = importlib.import_module(f'mpitools.{modname}')
                          all_docs.append(f'\n---\n\n# {modname.title()} Submodule\n\n')
                          sub_docs = document_module(submodule, f'mpitools.{modname}')
                          all_docs.extend(sub_docs)
                      except ImportError as e:
                          print(f'Could not import mpitools.{modname}: {e}')
          
          with open('API_DOCS.md', 'w') as f:
              f.write('\n'.join(all_docs))
          "
          
      - name: Commit changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add API_DOCS.md
          git diff --staged --quiet || git commit -m "Auto-update API documentation [skip ci]"
          git push